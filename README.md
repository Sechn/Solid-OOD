
# 1. شناسایی زیرمسائل و پیشنهاد الگوهای طراحی

در ادامه، سیستم به چند زیرمسئله‌ی اصلی شکسته شده و برای هر بخش، الگوی طراحی مناسب پیشنهاد می‌شود.

---

## زیرمسئله اول: مدیریت وضعیت‌های مختلف درخواست

### شرح مسئله

هر درخواست پشتیبانی (Ticket) در طول عمر خود چند وضعیت متوالی را طی می‌کند، از جمله:

- Created  
- Assigned  
- InProgress  
- Resolved  
- Closed  

رفتار سیستم در هر یک از این وضعیت‌ها متفاوت است. به عنوان مثال، در وضعیت `Closed` دیگر نباید هیچ عملیاتی روی درخواست انجام شود، در حالی که در وضعیت `Created` امکان ارجاع وجود دارد.

این موضوع نشان‌دهنده‌ی وجود رفتار وابسته به حالت (State-dependent behavior) در سیستم است.

### الگوی پیشنهادی: State Pattern

**دلیل انتخاب:**  
الگوی State برای مواقعی مناسب است که رفتار یک شیء بر اساس وضعیت داخلی آن تغییر کند. استفاده از این الگو باعث می‌شود منطق مربوط به هر وضعیت در کلاس جداگانه‌ای پیاده‌سازی شود و از استفاده‌ی بیش از حد از شرط‌های if/else جلوگیری گردد.

### روش اعمال الگو

- تعریف یک رابط مشترک برای وضعیت‌ها با نام `TicketState`
- پیاده‌سازی هر وضعیت در قالب یک کلاس مستقل مانند:
  - `CreatedState`
  - `AssignedState`
  - `InProgressState`
  - `ResolvedState`
  - `ClosedState`
- نگه‌داری یک مرجع از نوع `TicketState` در کلاس `Ticket` و واگذاری رفتارها به آن

---

## زیرمسئله دوم: تعیین واحد مسئول رسیدگی به درخواست

### شرح مسئله

پس از دریافت درخواست، سیستم باید تصمیم بگیرد که کدام واحد مسئول رسیدگی به آن است. این تصمیم معمولاً بر اساس نوع درخواست انجام می‌شود، مانند:

- درخواست‌های فنی → واحد فنی  
- درخواست‌های مالی → واحد مالی  
- درخواست‌های عمومی → واحد عمومی  

این تصمیم‌گیری یک الگوریتم متغیر است که ممکن است در آینده توسعه یابد.

### الگوی پیشنهادی: Strategy Pattern

**دلیل انتخاب:**  
الگوی Strategy برای پیاده‌سازی چند الگوریتم مختلف با یک رابط مشترک مناسب است. با استفاده از این الگو می‌توان الگوریتم تعیین واحد رسیدگی را بدون تغییر در ساختار کلی سیستم توسعه داد.

### روش اعمال الگو

- تعریف رابط `AssignmentStrategy`
- پیاده‌سازی استراتژی‌های مختلف مانند:
  - `TechnicalAssignmentStrategy`
  - `BillingAssignmentStrategy`
  - `GeneralAssignmentStrategy`
- انتخاب و استفاده از استراتژی مناسب در کلاس `TicketService`

---

## زیرمسئله سوم: نحوه‌ی پاسخ‌دهی به درخواست

### شرح مسئله

در طول رسیدگی به درخواست، سیستم باید پاسخ مناسبی تولید و ارسال کند. نوع پاسخ ممکن است بسته به شرایط متفاوت باشد، مانند:

- پاسخ از طریق Email  
- پاسخ از طریق SMS  
- پاسخ از طریق Web  

این تفاوت در روش پاسخ‌دهی نیز یک رفتار متغیر محسوب می‌شود.

### الگوی پیشنهادی: Strategy Pattern

**دلیل انتخاب:**  
با توجه به این‌که روش پاسخ‌دهی می‌تواند تغییر کند یا روش‌های جدیدی به آن اضافه شود، استفاده از Strategy باعث افزایش انعطاف‌پذیری سیستم می‌شود.

### روش اعمال الگو

- تعریف رابط `ResponseStrategy`
- پیاده‌سازی کلاس‌های:
  - `EmailResponseStrategy`
  - `SMSResponseStrategy`
  - `WebResponseStrategy`
- انتخاب استراتژی مناسب بر اساس نوع درخواست یا کانال ورودی

---

## زیرمسئله چهارم: ایجاد شیء Ticket

### شرح مسئله

درخواست‌ها می‌توانند از کانال‌های مختلفی مانند Web یا Email وارد سیستم شوند. در آینده ممکن است کانال‌های جدیدی نیز اضافه شوند. ایجاد شیء Ticket نباید در نقاط مختلف سیستم پراکنده باشد.

### الگوی پیشنهادی: Factory Pattern

**دلیل انتخاب:**  
الگوی Factory برای مدیریت فرآیند ایجاد اشیاء مناسب است و باعث می‌شود منطق ساخت اشیاء در یک محل متمرکز شود.

### روش اعمال الگو

- تعریف کلاس `TicketFactory`
- ایجاد متدهایی برای ساخت Ticket بر اساس نوع یا کانال ورودی
- استفاده از Factory به جای ایجاد مستقیم شیء با `new`

---

## زیرمسئله پنجم: ثبت رویداد (Logging)

### شرح مسئله

در پایان پردازش هر درخواست، لازم است یک پیام Log ثبت شود. ممکن است در آینده نیاز باشد این Log در مکان‌های مختلفی ذخیره شود (فایل، پایگاه داده، کنسول و …).

### الگوی پیشنهادی: Singleton و Observer

**دلیل انتخاب:**  
- Logger باید تنها یک نمونه در کل سیستم داشته باشد → استفاده از Singleton  
- امکان ثبت Log در چند مقصد مختلف → استفاده از Observer  

### روش اعمال الگو

- تعریف کلاس `Logger` به صورت Singleton  
- تعریف رابط `LogObserver`
- پیاده‌سازی Observerهای مختلف مانند:
  - `FileLogger`
  - `DatabaseLogger`
  - `ConsoleLogger`

---

## جمع‌بندی نهایی

در بازطراحی پیشنهادی سیستم، از الگوهای طراحی زیر استفاده شده است:

| زیرمسئله | الگوی طراحی |
|---------|-------------|
| مدیریت وضعیت‌ها | State |
| تعیین واحد رسیدگی | Strategy |
| پاسخ‌دهی | Strategy |
| ایجاد Ticket | Factory |
| ثبت رویداد | Singleton + Observer |

---

## نتیجه‌گیری

با اعمال الگوهای طراحی مطرح‌شده، سیستم مدیریت درخواست‌های پشتیبانی از یک ساختار ساده و وابسته به شرط‌ها به یک معماری ماژولار و توسعه‌پذیر تبدیل می‌شود. این بازطراحی باعث افزایش خوانایی کد، کاهش وابستگی بین کلاس‌ها و سهولت در توسعه و نگه‌داری سیستم خواهد شد.

---
---
---
## 2. توضیح کلاس دیاگرام سیستم مدیریت تیکت‌ها

این کلاس دیاگرام شامل چندین الگوی طراحی (Design Pattern) و کلاس‌های اصلی سیستم مدیریت تیکت است:

### ۱. الگوی State

- ا**TicketState (Interface):** رابطی برای وضعیت‌های مختلف تیکت با متدهای `handle(Ticket)` و `getStateName()`.

- کلاس‌های وضعیت:

  - `CreatedState`
  - `AssignedState`
  - `InProgressState`
  - `ResolvedState`
  - `ClosedState`

- **هدف:** مدیریت تغییرات وضعیت تیکت بدون نیاز به شرط‌های پیچیده. هر وضعیت رفتار مخصوص خود را هنگام پردازش تیکت دارد.

---
### ۲. الگوی Strategy

#### a. Assignment Strategy

- ا**AssignmentStrategy (Interface):** تعریف متد `assign(Ticket)`.

- کلاس‌های پیاده‌سازی:

  - `TechnicalAssignmentStrategy` 
  - `GeneralAssignmentStrategy`

- **هدف:** امکان تغییر استراتژی تخصیص تیکت به تیم‌های مختلف به صورت پویا.

#### b. Response Strategy

- ا**ResponseStrategy (Interface):** تعریف متد `sendResponse(Ticket, String)`.

- کلاس‌های پیاده‌سازی:

  - `EmailResponseStrategy`
  - `WebResponseStrategy`
  - `SMSResponseStrategy`

- **هدف:** ارسال پاسخ به تیکت‌ها از کانال‌های مختلف بدون تغییر در کلاس اصلی.

---
### ۳. الگوی Observer

- ا**LogObserver (Interface):** تعریف متد `log(String)`.
- کلاس‌های پیاده‌سازی:

  - `ConsoleLogger`
  - `FileLogger` (دارای فیلد filename)
  - `DatabaseLogger`

- ا**Logger (Singleton):** مدیریت لیست ناظرها و ارسال پیام‌های لاگ به آن‌ها.
- **هدف:** ثبت لاگ‌ها به صورت یکپارچه و اطلاع‌رسانی به چندین خروجی مختلف.

---
### ۴. الگوی Singleton

- ا**Logger:** تنها یک نمونه در سیستم دارد، و مدیریت لاگ‌ها را انجام می‌دهد.
- **هدف:** اطمینان از یکسان بودن لاگ در کل برنامه و جلوگیری از ایجاد چند نمونه.

---
### ۵. الگوی Factory

- ا**TicketFactory:** ایجاد انواع تیکت‌ها:
  - تیکت‌های عمومی
  - تیکت‌های وب
  - تیکت‌های ایمیلی
  - تیکت‌های باگ
  - تیکت‌های درخواست ویژگی
- **هدف:** جداسازی ساخت تیکت‌ها و مدیریت ساده‌تر انواع مختلف آن‌ها.

---
### ۶. کلاس‌های اصلی

- ا**Ticket:** نمایانگر یک تیکت با فیلدهای `id`, `state`, `channel`, `type`, `request`, `response`, `assignedTeam` و متدهای مدیریت وضعیت و اطلاعات تیکت.
- ا**TicketService:** پردازش تیکت‌ها با استفاده از استراتژی‌های تخصیص و پاسخ و ثبت لاگ‌ها.
- ا**Main:** نقطه شروع برنامه، استفاده از `TicketFactory` و `TicketService` برای ایجاد و پردازش تیکت‌ها.


---
---
---
# 4. تحلیل بهبود سیستم پس از اعمال الگوهای طراحی


## مقایسه اصول شی‌گرایی

### 1️⃣ Open/Closed Principle (OCP)
- **قبل:**  
  - افزودن وضعیت جدید یا تغییر الگوریتم رسیدگی به Ticket نیازمند تغییر مستقیم در کلاس‌های `Ticket` و `TicketService` بود.  
  - استفاده از شرط‌های if/else زیاد باعث پیچیدگی و شکنندگی کد می‌شد.
- **بعد:**  
  - افزودن وضعیت جدید یا الگوریتم جدید بدون تغییر در کلاس‌های اصلی امکان‌پذیر است (State و Strategy).  
- **بهبود:**  
  - سیستم باز برای توسعه و بسته برای تغییر شده است.  
- **نقاط ضعیف:**  
  - افزایش تعداد کلاس‌ها و فایل‌ها کمی مدیریت پروژه را پیچیده‌تر کرده است.

---

### 2️⃣ Single Responsibility Principle (SRP)
- **قبل:**  
  - کلاس‌های `Ticket` و `TicketService` مسئولیت‌های متعددی داشتند:  
    - مدیریت وضعیت‌ها  
    - ارسال پاسخ  
    - ثبت Log  
    - تصمیم‌گیری واحد رسیدگی
- **بعد:**  
  - هر وظیفه به کلاس مستقل منتقل شد:  
    - وضعیت‌ها → کلاس‌های State (`CreatedState`, `AssignedState`, ...)  
    - الگوریتم رسیدگی → Strategy (`TechnicalAssignmentStrategy`, ...)  
    - ثبت لاگ → Logger Singleton + Observer
- **بهبود:**  
  - هر کلاس تنها یک مسئولیت دارد و نگه‌داری آن ساده‌تر شده است.
- **نقاط ضعیف:**  
  - تعداد کلاس‌ها افزایش یافته و ممکن است برای افراد تازه‌کار کمی گیج‌کننده باشد.

---

### 3️⃣ Coupling / Law of Demeter (CRP / PLK)
- **قبل:**  
  - وابستگی‌های قوی بین `Ticket` و `TicketService` و منطق شرطی داخلی باعث coupling بالا و شکنندگی سیستم بود.
- **بعد:**  
  - با واگذاری رفتارها به State و Strategy، وابستگی‌ها کاهش یافته و کلاس‌ها کمتر به جزئیات داخلی یکدیگر وابسته‌اند.
- **بهبود:**  
  - سیستم انعطاف‌پذیرتر و قابل تست‌تر شده است.
- **نقاط ضعیف:**  
  - پیچیدگی ساختاری و تعداد مراجع در پروژه کمی بیشتر شده است، اما این هزینه برای کاهش وابستگی‌ها قابل قبول است.

---
## تغییرات
- **نقاط قوت:**  
  - توسعه‌پذیری بالا  
  - نگه‌داری آسان‌تر  
  - خوانایی بهتر کد  
  - کاهش if/else های پیچیده
- **نقاط ضعف:**  
  - افزایش تعداد کلاس‌ها  
  - پیچیدگی نسبی مسیرهای کدنویسی

---
## در نتیجه‌:
با اعمال الگوهای طراحی، سیستم مدیریت درخواست‌های پشتیبانی از یک ساختار ساده و شرطی به یک معماری **ماژولار، توسعه‌پذیر و منطبق با اصول شی‌گرایی** تبدیل شده است.
